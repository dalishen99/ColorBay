# TokenRelease.min.sol
**1, 该函数需要删除，区块的时间是矿工决定的，不可修改。**
    function setBlockTimestamp(uint256 _timestamp) public {
        block.timestamp = _timestamp;
    }
    
**2，该函数做了检查和增加2个事情，函数名只包含检查描述，从编程规范角度看不合理。**
    modifier checkPayPool(uint256 _totalToken) {
        require(token.balanceOf(this) >= payPool.add(_totalToken));
        payPool = payPool.add(_totalToken);
        _;
    }
    
 **3，_locktoTime可以为等于_startTime，针对没有锁定期的情况；_endTime必须>=_locktoTime的检查**
function addPlan(address _beneficiary, uint256 _startTime, uint256 _locktoTime, uint256 _releaseStages, uint256 _endTime, uint256 _totalToken, bool _revocable, string _remark) public checkPayPool(_totalToken) returns (bool) {
        require(_beneficiary != address(0));
        //require(plans[_beneficiary] != 0);
        require(_startTime > 0 && _locktoTime > 0 && _releaseStages > 0 && _totalToken > 0);
        require(_locktoTime > block.timestamp && _locktoTime > _startTime);

**4. release函数的_beneficiary应该不等于0，做检查；isRevoked应该也允许释放？**

function release(address _beneficiary) public {
    //require(plans[_beneficiary] != 0);
      require(!plans[_beneficiary].isRevoked);       
  
  /* 按照官方建议，入参检查用require, 结果验证用assert？ */
  /* unreleased > 0 是可能的，不应该运行回滚，而是做if的判断，不要跑释放函数内容即可。 */
      
  uint256 unreleased = releasableAmount(_beneficiary);
  require(unreleased > 0 && unreleased <= plans[_beneficiary].totalToken);        
  
**5. 该函数是不是要增加个大小检查判断，防止异常溢出为超大值呢？**  
    function releasableAmount(address _beneficiary) public view returns (uint256) {
        //require(plans[msg.sender] != 0);
        return vestedAmount(_beneficiary).sub(plans[_beneficiary].releasedAmount);
    }  
    
**6. 逻辑**
function vestedAmount(address _beneficiary) public view returns (uint256) {

/* 第2,3个检查的意义要讨论一下，目前觉得没有必要 */
/* 应该允许被授权方在撤回代币前，自行释放的权利 */
        if (block.timestamp <= plans[_beneficiary].locktoTime || (block.timestamp > plans[_beneficiary].endTime && plans[_beneficiary].totalToken == plans[_beneficiary].releasedAmount) || plans[_beneficiary].isRevoked) {
            return 0;
        }
        
    
        
        
        
        

    
    
    
